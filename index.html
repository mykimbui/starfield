<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Warp Speed Starfield</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #080F1E;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        canvas {
            display: block;
        }
        
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 14px;
            z-index: 100;
        }
        
        .controls label {
            display: block;
            margin-bottom: 10px;
        }
        
        .controls input[type="range"] {
            width: 150px;
            margin-left: 10px;
        }
    </style>
</head>
<body>
            <div class="controls">
            <label>Speed: <input type="range" id="speedSlider" min="0.1" max="1.5" value="0.3" step="0.1"></label>
            <label>Stars: <input type="range" id="starSlider" min="500" max="5000" value="2000" step="100"></label>
            <label>Influence Radius: <input type="range" id="radiusSlider" min="50" max="200" value="100" step="10"></label>
            <label>Attraction Force: <input type="range" id="forceSlider" min="0.01" max="0.5" value="0.1" step="0.01"></label>
        </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer;
        let stars = [];
        let starGeometry, starMaterial, starField;
        let backgroundStars = [];
        let backgroundStarGeometry, backgroundStarMaterial, backgroundStarField;
        let speed = 0.3;
        let numStars = 2000;
        let numBackgroundStars = 5000; // More background stars for density
        let mouseX = 0, mouseY = 0;
        let isHovering = false;
        let influenceRadius = 100; // Configurable influence radius
        let attractionForce = 0.1; // Force strength for attraction (reduced)
        let mouseVelocity = { x: 0, y: 0 };
        let lastMouseX = 0, lastMouseY = 0;
        let mouseMoving = false;
        let mouseStopTimer = null;
        let mouseWorldPosition = new THREE.Vector3(); // 3D world position of mouse
        let forceDecayRate = 0.95; // How quickly forces decay when mouse stops
        
        // Star class to track position and previous position
        class Star {
            constructor() {
                this.reset();
                this.originalX = 0;
                this.originalY = 0;
                this.originalZ = 0;
                this.velocityX = 0;
                this.velocityY = 0;
                this.velocityZ = 0;
                this.attractionForceX = 0;
                this.attractionForceY = 0;
                this.attractionForceZ = 0;
                this.isInfluenced = false;
                this.influenceFactor = 0;
            }
            
            // Background star class (simpler, no physics)
            static createBackgroundStar() {
                const star = {
                    x: 0, y: 0, z: 0,
                    size: Math.random() * 3 + 1,
                    brightness: Math.random() * 0.6 + 0.4,
                    twinkleSpeed: Math.random() * 0.02 + 0.01,
                    twinklePhase: Math.random() * Math.PI * 2
                };
                star.reset = function() {
                    // Spawn background stars in a large volume, behind but visible
                    const angle = Math.random() * Math.PI * 2;
                    const elevation = Math.random() * Math.PI - Math.PI / 2;
                    const radius = Math.random() * 100 + 30; // Smaller radius, closer to center
                    
                    this.x = Math.cos(angle) * Math.cos(elevation) * radius;
                    this.y = Math.sin(elevation) * radius;
                    this.z = -Math.random() * 100 - 80; // Much closer, more visible
                    
                    this.size = Math.random() * 5 + 3; // Even larger for better visibility
                    this.brightness = Math.random() * 0.9 + 0.1; // Very bright
                    this.twinkleSpeed = Math.random() * 0.02 + 0.01;
                    this.twinklePhase = Math.random() * Math.PI * 2;
                };
                star.update = function() {
                    // Background stars stay in the background - no forward movement
                    // Only twinkle effect
                    this.twinklePhase += this.twinkleSpeed;
                    
                    // Very slow movement to create subtle parallax effect
                    this.z += speed * 0.1;
                    
                    // Reset if they get too close (but they should stay far back)
                    if (this.z > -100) {
                        this.reset();
                    }
                };
                star.reset();
                return star;
            }
            
            reset() {
                // Spawn stars in a cylindrical volume ahead of camera
                const angle = Math.random() * Math.PI * 2;
                const radius = Math.random() * 50;
                this.x = Math.cos(angle) * radius;
                this.y = Math.sin(angle) * radius;
                this.z = -Math.random() * 200 - 50; // Start far ahead
                
                this.prevX = this.x;
                this.prevY = this.y;
                this.prevZ = this.z;
                
                this.originalX = this.x;
                this.originalY = this.y;
                this.originalZ = this.z;
                
                // Reset velocities and forces
                this.velocityX = 0;
                this.velocityY = 0;
                this.velocityZ = 0;
                this.attractionForceX = 0;
                this.attractionForceY = 0;
                this.attractionForceZ = 0;
            }
            
            update() {
                this.prevX = this.x;
                this.prevY = this.y;
                this.prevZ = this.z;
                
                // Calculate normal warp motion (forward toward camera)
                const warpSpeedZ = speed * 0.8;
                
                // Apply attraction forces if influenced
                if (this.isInfluenced) {
                    this.applyAttractionForce();
                }
                
                // Apply velocity to position (physics-based movement)
                this.x += this.velocityX;
                this.y += this.velocityY;
                this.z += this.velocityZ + warpSpeedZ; // Combine attraction with warp motion
                
                // Expand outward from center as they get closer (original warp effect)
                const progress = (this.z + 50) / 200;
                if (progress > 0) {
                    const expansion = progress * progress * 3;
                    this.x *= (1 + expansion * 0.02);
                    this.y *= (1 + expansion * 0.02);
                }
                
                // Decay forces when mouse stops moving
                if (!mouseMoving && this.isInfluenced) {
                    this.decayForces();
                }
                
                // Reset if passed camera
                if (this.z > 10) {
                    this.reset();
                }
                
                // Create artificial trail length for better visibility
                const direction = Math.sqrt(this.x * this.x + this.y * this.y);
                if (direction > 0) {
                    const trailLength = 2 + speed * 4; // Shorter trail length
                    const normalizedX = this.x / direction;
                    const normalizedY = this.y / direction;
                    
                    this.prevX = this.x - normalizedX * trailLength;
                    this.prevY = this.y - normalizedY * trailLength;
                    this.prevZ = this.z - trailLength * 0.3;
                }
            }
            
            applyAttractionForce() {
                // Calculate 3D distance to mouse
                const distanceToMouse = Math.sqrt(
                    Math.pow(this.x - mouseWorldPosition.x, 2) + 
                    Math.pow(this.y - mouseWorldPosition.y, 2) +
                    Math.pow(this.z - mouseWorldPosition.z, 2)
                );
                
                // Calculate attraction force based on distance (inverse square law)
                const forceMagnitude = attractionForce / (distanceToMouse * distanceToMouse + 1);
                
                // Calculate direction vector from star to mouse
                const directionX = mouseWorldPosition.x - this.x;
                const directionY = mouseWorldPosition.y - this.y;
                const directionZ = mouseWorldPosition.z - this.z;
                
                // Normalize direction vector
                const directionLength = Math.sqrt(directionX * directionX + directionY * directionY + directionZ * directionZ);
                if (directionLength > 0) {
                    const normalizedX = directionX / directionLength;
                    const normalizedY = directionY / directionLength;
                    const normalizedZ = directionZ / directionLength;
                    
                    // Apply force to velocity (F = ma, simplified as F = v)
                    this.velocityX += normalizedX * forceMagnitude * this.influenceFactor;
                    this.velocityY += normalizedY * forceMagnitude * this.influenceFactor;
                    this.velocityZ += normalizedZ * forceMagnitude * this.influenceFactor;
                }
                
                // Apply damping to prevent excessive speed
                const damping = 0.95;
                this.velocityX *= damping;
                this.velocityY *= damping;
                this.velocityZ *= damping;
            }
            
            decayForces() {
                // Gradually reduce attraction forces
                this.attractionForceX *= forceDecayRate;
                this.attractionForceY *= forceDecayRate;
                this.attractionForceZ *= forceDecayRate;
                
                // Decay velocities back toward normal warp motion
                this.velocityX *= forceDecayRate;
                this.velocityY *= forceDecayRate;
                this.velocityZ *= forceDecayRate;
                
                // Reset influence when forces are small enough
                if (Math.abs(this.velocityX) < 0.01 && Math.abs(this.velocityY) < 0.01 && Math.abs(this.velocityZ) < 0.01) {
                    this.isInfluenced = false;
                    this.influenceFactor = 0;
                }
            }
        }
        
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x080F1E);
            document.body.appendChild(renderer.domElement);
            
            camera.position.z = 0;
            
            createStarField();
            setupControls();
            animate();
        }
        
        function createStarField() {
            // Create main star instances
            stars = [];
            for (let i = 0; i < numStars; i++) {
                stars.push(new Star());
            }
            
            // Create background star instances
            backgroundStars = [];
            for (let i = 0; i < numBackgroundStars; i++) {
                backgroundStars.push(Star.createBackgroundStar());
            }
            
            // Create geometry for main star lines
            starGeometry = new THREE.BufferGeometry();
            const positions = new Float32Array(numStars * 6);
            const colors = new Float32Array(numStars * 6);
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            starGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // Material for the main star streaks
            starMaterial = new THREE.LineBasicMaterial({ 
                vertexColors: true,
                transparent: true,
                blending: THREE.AdditiveBlending,
                linewidth: 12
            });
            
            // Create main star field
            starField = new THREE.LineSegments(starGeometry, starMaterial);
            scene.add(starField);
            
            // Create geometry for background stars (points instead of lines)
            backgroundStarGeometry = new THREE.BufferGeometry();
            const bgPositions = new Float32Array(numBackgroundStars * 3);
            const bgColors = new Float32Array(numBackgroundStars * 3);
            const bgSizes = new Float32Array(numBackgroundStars);
            
            backgroundStarGeometry.setAttribute('position', new THREE.BufferAttribute(bgPositions, 3));
            backgroundStarGeometry.setAttribute('color', new THREE.BufferAttribute(bgColors, 3));
            backgroundStarGeometry.setAttribute('size', new THREE.BufferAttribute(bgSizes, 1));
            
            // Material for background stars with glow effect
            backgroundStarMaterial = new THREE.PointsMaterial({
                vertexColors: true,
                transparent: true,
                blending: THREE.AdditiveBlending,
                size: 8,
                sizeAttenuation: true,
                map: createGlowTexture(),
                depthWrite: false,
                depthTest: false
            });
            
            // Create background star field
            backgroundStarField = new THREE.Points(backgroundStarGeometry, backgroundStarMaterial);
            backgroundStarField.renderOrder = -1; // Render background first
            scene.add(backgroundStarField);
            
            updateStarField();
        }
        
        function createGlowTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            
            // Create radial gradient for glow effect
            const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
            gradient.addColorStop(0.2, 'rgba(255, 255, 255, 0.9)');
            gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.5)');
            gradient.addColorStop(0.8, 'rgba(255, 255, 255, 0.2)');
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 64, 64);
            
            const texture = new THREE.CanvasTexture(canvas);
            texture.needsUpdate = true;
            return texture;
        }
        
        function updateStarField() {
            const positions = starGeometry.attributes.position.array;
            const colors = starGeometry.attributes.color.array;
            
            // Update mouse influence on stars only when hovering
            if (isHovering) {
                updateMouseInfluence();
            }
            
            // Update main stars
            for (let i = 0; i < stars.length; i++) {
                const star = stars[i];
                star.update();
                
                const i6 = i * 6; // 6 values per star (2 vertices * 3 coordinates)
                
                // Previous position (start of line)
                positions[i6] = star.prevX;
                positions[i6 + 1] = star.prevY;
                positions[i6 + 2] = star.prevZ;
                
                // Current position (end of line)
                positions[i6 + 3] = star.x;
                positions[i6 + 4] = star.y;
                positions[i6 + 5] = star.z;
                
                // Calculate brightness based on distance and speed
                const distance = Math.sqrt(star.x * star.x + star.y * star.y);
                
                // Brighter as stars come closer to camera (depth)
                const depthFactor = Math.min(1, (star.z + 50) / 100);
                
                // Less bright only near the center point (creates dark center)
                const centerFade = Math.min(1, distance / 20); // Fade out near center
                
                const brightness = depthFactor * centerFade;
                const alpha = Math.max(0.05, brightness);
                
                // Set colors for both vertices
                colors[i6] = alpha * 0.7;     // R (dimmer at start)
                colors[i6 + 1] = alpha * 0.7; // G
                colors[i6 + 2] = alpha * 0.7; // B
                
                colors[i6 + 3] = alpha;       // R (brighter at end)
                colors[i6 + 4] = alpha;       // G
                colors[i6 + 5] = alpha;       // B
            }
            
            // Update background stars
            if (backgroundStarGeometry && backgroundStarGeometry.attributes) {
                const bgPositions = backgroundStarGeometry.attributes.position.array;
                const bgColors = backgroundStarGeometry.attributes.color.array;
                const bgSizes = backgroundStarGeometry.attributes.size.array;
                
                for (let i = 0; i < backgroundStars.length; i++) {
                    const star = backgroundStars[i];
                    star.update();
                    
                    const i3 = i * 3;
                    
                    // Position
                    bgPositions[i3] = star.x;
                    bgPositions[i3 + 1] = star.y;
                    bgPositions[i3 + 2] = star.z;
                    
                    // Twinkling brightness
                    const twinkle = Math.sin(star.twinklePhase) * 0.3 + 0.7;
                    const depthFactor = Math.min(1, (star.z + 80) / 150);
                    const brightness = star.brightness * depthFactor * twinkle;
                    
                    // Brighter colors for better visibility
                    bgColors[i3] = brightness;     // R (full brightness)
                    bgColors[i3 + 1] = brightness; // G (full brightness)
                    bgColors[i3 + 2] = brightness; // B (full brightness)
                    
                    // Larger size for better visibility
                    bgSizes[i] = star.size * brightness * 5;
                }
                
                backgroundStarGeometry.attributes.position.needsUpdate = true;
                backgroundStarGeometry.attributes.color.needsUpdate = true;
                backgroundStarGeometry.attributes.size.needsUpdate = true;
            }
            
            starGeometry.attributes.position.needsUpdate = true;
            starGeometry.attributes.color.needsUpdate = true;
        }
        
        function updateMouseInfluence() {
            // Only update influence when mouse is moving
            if (!mouseMoving) {
                return;
            }
            
            // Convert mouse screen coordinates to 3D world coordinates
            const mouseScreenX = (mouseX / window.innerWidth) * 2 - 1;
            const mouseScreenY = -(mouseY / window.innerHeight) * 2 + 1;
            
            // Create a ray from camera through mouse position
            const mouseVector = new THREE.Vector3(mouseScreenX, mouseScreenY, 0.5);
            mouseVector.unproject(camera);
            
            // Set mouse world position at a fixed distance from camera
            const mouseDistance = 50; // Distance from camera
            mouseWorldPosition.copy(mouseVector).normalize().multiplyScalar(mouseDistance);
            
            // Check all stars within influence radius (no fixed percentage limit)
            stars.forEach(star => {
                const distanceToMouse = Math.sqrt(
                    Math.pow(star.x - mouseWorldPosition.x, 2) + 
                    Math.pow(star.y - mouseWorldPosition.y, 2) +
                    Math.pow(star.z - mouseWorldPosition.z, 2)
                );
                
                if (distanceToMouse <= influenceRadius) {
                    star.isInfluenced = true;
                    // Calculate influence factor based on distance (closer = stronger)
                    star.influenceFactor = Math.max(0, 1 - (distanceToMouse / influenceRadius));
                } else {
                    // Star is outside influence radius
                    star.isInfluenced = false;
                    star.influenceFactor = 0;
                }
            });
        }
        
        function setupControls() {
            const speedSlider = document.getElementById('speedSlider');
            const starSlider = document.getElementById('starSlider');
            const radiusSlider = document.getElementById('radiusSlider');
            const forceSlider = document.getElementById('forceSlider');
            
            speedSlider.addEventListener('input', (e) => {
                speed = parseFloat(e.target.value);
            });
            
            starSlider.addEventListener('input', (e) => {
                const newNumStars = parseInt(e.target.value);
                if (newNumStars !== numStars) {
                    numStars = newNumStars;
                    scene.remove(starField);
                    scene.remove(backgroundStarField);
                    createStarField();
                }
            });
            
            radiusSlider.addEventListener('input', (e) => {
                influenceRadius = parseFloat(e.target.value);
            });
            
            forceSlider.addEventListener('input', (e) => {
                attractionForce = parseFloat(e.target.value);
            });
        }
        
        function animate() {
            requestAnimationFrame(animate);
            updateStarField();
            renderer.render(scene, camera);
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Start the experience
        init();
        
        // Mouse event listeners for star clustering
        renderer.domElement.addEventListener('mouseenter', () => {
            isHovering = true;
        });
        
        renderer.domElement.addEventListener('mouseleave', () => {
            isHovering = false;
            mouseMoving = false;
            // Reset all stars to normal trajectory
            stars.forEach(star => {
                star.isInfluenced = false;
                star.influenceFactor = 0;
                star.velocityX = 0;
                star.velocityY = 0;
                star.velocityZ = 0;
            });
        });
        
        renderer.domElement.addEventListener('mousemove', (e) => {
            // Calculate mouse velocity
            mouseVelocity.x = e.clientX - lastMouseX;
            mouseVelocity.y = e.clientY - lastMouseY;
            
            // Update mouse position
            mouseX = e.clientX;
            mouseY = e.clientY;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            
            // Set mouse as moving
            mouseMoving = true;
            
            // Clear existing timer
            if (mouseStopTimer) {
                clearTimeout(mouseStopTimer);
            }
            
            // Set timer to detect when mouse stops moving
            mouseStopTimer = setTimeout(() => {
                mouseMoving = false;
            }, 100); // 100ms delay before considering mouse stopped
        });
    </script>
</body>
</html>