<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Logo - Three.js</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #080F1E;
            font-family: Arial, sans-serif;
        }
        
        #container {
            width: 100vw;
            height: 100vh;
            cursor: none;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            z-index: 100;
            font-size: 14px;
        }
        
        #upload {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
        }
        
        #upload input {
            padding: 8px;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.3);
            color: white;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div id="container"></div>
    <div id="info">
        <div>Move your mouse to interact with particles within the SVG text</div>
        <div>Particles: <span id="particleCount">0</span> (Constrained within letter shapes)</div>
        <div>FPS: <span id="fps">0</span></div>
    </div>
    <div id="upload">
        <input type="file" id="imageInput" accept="image/*" />
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    
    <script>
        // Configuration
        const controlsConfig = {
            magnetStrength: 0.05,
            particleSize:1,
            returnSpeed: 0.005,
            spreadDistance: 1000,
            effectRadius: 160,
            windDirection: 0,
            windStrength: 0.0005,
            buoyancy: 0.005,
            brownianStrength: 0.005,
            turbulence: 0.002,
            driftIndependence: 0.02,
            inertialDamping: 0.98,
            forceFade: 0.995,
            mouseForce: 0.4,
            syncOffset: 1.0,
            noiseOneMultiplier: 0.002,
            noiseTwoMultiplier: 0.001,
            noiseThreeMultiplier: 0.0005,
            reactionDiversity: 0.1,
            accelerationSmooth: 8.0,
            flowCoherence: 0.95
        };

        // Vertex Shader (from the actual component)
        const vertexShader = `
            precision mediump float;
            
            attribute vec3 originalPosition;
            attribute vec3 color;
            attribute float size;
            attribute float sensitivity;
            attribute float mass;
            attribute float phase;

            uniform vec2 uResolution;
            uniform float uTime;
            uniform float uParticleSize;
            uniform float uYOffset;

            float random(vec2 st) {
                return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
            }

            float noise(vec2 st) {
                vec2 i = floor(st);
                vec2 f = fract(st);
                
                float a = random(i);
                float b = random(i + vec2(1.0, 0.0));
                float c = random(i + vec2(0.0, 1.0));
                float d = random(i + vec2(1.0, 1.0));
                
                vec2 u = f * f * (3.0 - 2.0 * f);
                return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;
            }

            void main() {
                vec2 pPosition = (position.xy / uResolution) * 2.0 - 1.0;
                pPosition.y = -pPosition.y;

                pPosition.y += uYOffset;
                
                gl_Position = vec4(pPosition, 0.0, 1.0);
                
                float personalBreathing = sin(uTime * 0.00002 + phase) * sensitivity; // Ultra-slow breathing
                float sizeNoise = noise(originalPosition.xy * 0.001 + uTime * 0.00005) - 0.5; // Ultra-gentle noise
                float dynamicSize = uParticleSize + ((sizeNoise + personalBreathing) * 0.02); // Ultra-minimal variation
                
                // Reduce visual jitter when mouse is near (this would need to be passed as uniform)
                // For now, we'll keep the visual effects consistent
                gl_PointSize = max(2.0, dynamicSize * mass); // Much larger minimum size
            }
        `;

        // Fragment Shader (from the actual component)
        const fragmentShader = `
            precision mediump float;
                                
            uniform vec3 uOverrideColor;

            void main() {
                vec2 center = gl_PointCoord - 0.5;
                float dist = length(center);
                
                if (dist > 0.5) {
                    discard;
                }
                
                gl_FragColor = vec4(uOverrideColor, 1.0);
            }
        `;

        // Utility function to get pixel data from SVG and create boundary detection
        function getPixelDataFromImage(image, viewport, scale) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Scale the canvas based on desired detail level - higher resolution for more particles
            const maxSize = 1200;
            let canvasWidth = image.width;
            let canvasHeight = image.height;
            
            if (canvasWidth > maxSize || canvasHeight > maxSize) {
                const aspectRatio = canvasWidth / canvasHeight;
                if (canvasWidth > canvasHeight) {
                    canvasWidth = maxSize;
                    canvasHeight = maxSize / aspectRatio;
                } else {
                    canvasHeight = maxSize;
                    canvasWidth = maxSize * aspectRatio;
                }
            }
            
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            ctx.drawImage(image, 0, 0, canvasWidth, canvasHeight);
            
            const imageData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
            const data = imageData.data;
            const particles = [];
            
            // Create boundary detection canvas - same size as particle canvas
            const boundaryCanvas = document.createElement('canvas');
            const boundaryCtx = boundaryCanvas.getContext('2d');
            boundaryCanvas.width = canvasWidth;
            boundaryCanvas.height = canvasHeight;
            boundaryCtx.drawImage(image, 0, 0, canvasWidth, canvasHeight);
            const boundaryData = boundaryCtx.getImageData(0, 0, canvasWidth, canvasHeight);
            
            // Sample pixels to create particles
            const step = Math.max(1, Math.floor(Math.min(canvasWidth, canvasHeight) / 200));
            
            // Calculate scaling to center the image in viewport
            const imageAspect = canvasWidth / canvasHeight;
            const viewportAspect = viewport.width / viewport.height;
            
            let scaleX, scaleY;
            
            if (imageAspect > viewportAspect) {
                scaleX = viewport.width * scale * 1.3;
                scaleY = scaleX / imageAspect;
            } else {
                scaleY = viewport.height * scale * 1.3;
                scaleX = scaleY * imageAspect;
            }
            
            const offsetX = (viewport.width - scaleX) / 2;
            const offsetY = (viewport.height - scaleY) / 2;
            
            // Store image bounds and scaling info for boundary checking
            const imageBounds = {
                left: offsetX,
                right: offsetX + scaleX,
                top: offsetY,
                bottom: offsetY + scaleY,
                width: scaleX,
                height: scaleY,
                canvasWidth: canvasWidth,
                canvasHeight: canvasHeight,
                scaleX: scaleX / canvasWidth,
                scaleY: scaleY / canvasHeight,
                offsetX: offsetX,
                offsetY: offsetY,
                boundaryData: boundaryData.data
            };
            
            for (let y = 0; y < canvasHeight; y += step) {
                for (let x = 0; x < canvasWidth; x += step) {
                    const i = (y * canvasWidth + x) * 4;
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    const a = data[i + 3];
                    
                    if (a > 20) {
                        const normalizedX = x / canvasWidth;
                        const normalizedY = y / canvasHeight;
                        
                        const scaledX = offsetX + normalizedX * scaleX;
                        const scaledY = offsetY + normalizedY * scaleY;
                        
                        particles.push({
                            originalX: scaledX,
                            originalY: scaledY,
                            currentX: scaledX,
                            currentY: scaledY,
                            size: Math.random() * 0.4 + 2.0, // Much larger base size
                            sensitivity: Math.random() * 0.6 + 0.4,
                            mass: Math.random() * 0.6 + 0.4,
                            phase: Math.random() * Math.PI * 2,
                            vx: 0,
                            vy: 0,
                            personalDrift: Math.random() * Math.PI * 2,
                            lastActiveFrame: 0,
                            reactionDelay: Math.floor(Math.random() * 10) + 5
                        });
                    }
                }
            }
            
            return { particles, imageBounds };
        }

        // Function to check if a point is inside the SVG boundaries
        function isInsideSVGBounds(x, y, imageBounds) {
            if (!imageBounds || !imageBounds.boundaryData) return true;
            
            // Convert screen coordinates back to canvas coordinates
            const canvasX = Math.floor((x - imageBounds.offsetX) / imageBounds.scaleX);
            const canvasY = Math.floor((y - imageBounds.offsetY) / imageBounds.scaleY);
            
            // Check bounds
            if (canvasX < 0 || canvasX >= imageBounds.canvasWidth || 
                canvasY < 0 || canvasY >= imageBounds.canvasHeight) {
                return false;
            }
            
            // Check pixel data - if alpha > 0, point is inside SVG
            const index = (canvasY * imageBounds.canvasWidth + canvasX) * 4 + 3; // Alpha channel
            return imageBounds.boundaryData[index] > 20; // Same threshold as particle creation
        }

        // Function to find nearest valid position inside SVG bounds
        function findNearestValidPosition(x, y, imageBounds, searchRadius = 20) {
            if (isInsideSVGBounds(x, y, imageBounds)) return { x, y };
            
            // Spiral search for nearest valid position
            for (let radius = 1; radius <= searchRadius; radius++) {
                for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 8) {
                    const testX = x + Math.cos(angle) * radius;
                    const testY = y + Math.sin(angle) * radius;
                    
                    if (isInsideSVGBounds(testX, testY, imageBounds)) {
                        return { x: testX, y: testY };
                    }
                }
            }
            
            return { x, y }; // Fallback to original position
        }

        // Lerp function
        function lerp(a, b, t) {
            return a + t * (b - a);
        }

        // Main Application
        class InteractiveLogo {
            constructor() {
                this.container = document.getElementById('container');
                this.scene = new THREE.Scene();
                this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                
                this.mouse = new THREE.Vector2(-1, -1);
                this.mouseLerp = new THREE.Vector2(-1, -1);
                this.lastMouse = new THREE.Vector2(-1, -1);
                this.velocity = new THREE.Vector2(0, 0);
                
                this.particles = [];
                this.particleSystem = null;
                this.backgroundMesh = null;
                this.imageBounds = null; // Store image boundaries for particle constraints
                
                this.clock = new THREE.Clock();
                this.lastTime = 0;
                this.frameCount = 0;
                this.fps = 0;
                
                this.hasLoaded = false;
                this.inView = true;
                
                this.backgroundColor = '#080F1E';
                this.foregroundColor = '#FFFFFF';
                
                this.init();
                this.setupEventListeners();
                this.animate();
                
                // Load a default texture (create a simple pattern)
                this.createDefaultTexture();
            }
            
            init() {
                // Configure renderer to match Canvas settings
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                this.renderer.outputColorSpace = THREE.SRGBColorSpace;
                this.renderer.toneMapping = THREE.LinearToneMapping;
                this.renderer.setClearColor(0x080F1E, 1); // Set to match background color
                
                this.container.appendChild(this.renderer.domElement);
                
                // Camera settings to match Canvas configuration
                this.camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, 0.1, 1000);
                this.camera.position.set(0, 0, 1000);
                
                // Create background
                this.createBackground();
                
                // Update responsive settings
                this.updateResponsiveSettings();
            }
            
            createBackground() {
                const geometry = new THREE.PlaneGeometry(2000, 2000);
                const material = new THREE.MeshBasicMaterial({ 
                    color: new THREE.Color(this.backgroundColor) 
                });
                this.backgroundMesh = new THREE.Mesh(geometry, material);
                this.backgroundMesh.position.z = -10;
                this.scene.add(this.backgroundMesh);
            }
            
            createDefaultTexture() {
                // Use the provided "Professional" SVG data
                const svgString = `<svg xmlns="http://www.w3.org/2000/svg" width="17930" height="1546" fill="none"><path fill="#fff" d="M17196.9 1535.59v-376.27h71.2c24.4 187.12 152.5 298.98 321.3 298.98 136.3 0 207.5-75.25 207.5-176.95 0-264.4-600-91.52-600-498.3 0-142.372 111.9-294.915 335.6-294.915 132.2 0 191.2 61.017 238 61.017 20.3 0 40.6-6.101 40.6-50.847h67.2v335.593h-71.2c-12.2-142.373-111.9-258.305-264.4-258.305-142.4 0-213.6 75.254-213.6 166.779 0 264.408 600 91.526 600 498.308 0 152.54-101.7 305.08-325.4 305.08-152.6 0-223.8-71.18-286.8-71.18-26.4 0-50.9 12.2-52.9 61.01h-67.1ZM16992.5 1128.81h71.2c-18.3 217.63-154.6 416.95-396.6 416.95-272.5 0-447.5-209.49-447.5-518.64 0-315.256 175-538.985 433.3-538.985 278.6 0 410.8 223.729 410.8 477.966H16362c0 274.579 136.3 427.119 327.5 427.119 162.7 0 260.3-97.63 303-264.41Zm-624.4-250.166h520.7c0-189.153-85.4-303.051-238-303.051-140.3 0-254.2 101.695-282.7 303.051ZM16047.2 1128.81h71.2c-18.3 211.53-132.2 416.95-392.5 416.95-272.6 0-441.4-219.66-441.4-514.57 0-309.157 177-543.055 453.6-543.055 221.7 0 360 160.678 360 333.559 0 67.119-28.5 124.068-99.7 124.068-42.7 0-83.4-36.61-83.4-89.491 0-32.543 10.2-63.051 10.2-103.729 0-85.424-50.8-176.949-189.2-176.949-162.7 0-309.1 130.169-309.1 390.508 0 254.239 134.2 427.119 329.5 427.119 160.7 0 252.2-103.73 290.8-264.41ZM14883.6 183.051c0-58.983 46.8-107.797 105.7-107.797 59 0 107.8 48.814 107.8 107.797s-48.8 105.762-107.8 105.762c-58.9 0-105.7-46.779-105.7-105.762Zm-91.5 1342.369v-75.25h10.1c52.9 0 77.3-8.14 95.6-26.44 18.3-18.31 26.5-44.75 26.5-95.6V705.762c0-50.847-8.2-77.288-26.5-95.593-18.3-18.305-42.7-26.441-95.6-26.441h-10.1v-75.254h274.5v819.656c0 50.85 8.2 77.29 26.5 95.6 18.3 18.3 42.7 26.44 95.6 26.44h10.1v75.25h-406.7ZM14236.1 1535.59l-339.7-809.489c-38.6-91.525-75.2-142.373-148.4-142.373v-75.254h386.4v75.254c-63.1 0-101.7 28.475-101.7 79.322 0 20.339 6.1 44.746 18.3 75.254l240 573.556 213.6-573.556c12.2-30.508 16.2-54.915 16.2-75.254 0-46.78-32.5-79.322-101.7-79.322v-75.254h345.8v75.254c-71.2 0-120 44.746-166.8 170.847l-290.8 781.015h-71.2ZM12963.5 1525.42v-75.25h10.2c52.9 0 77.3-8.14 95.6-26.44 18.3-18.31 26.4-44.75 26.4-95.6V703.728c0-48.813-8.1-75.254-26.4-93.559-18.3-18.305-42.7-26.44-95.6-26.44h-10.2v-75.255h264.4v233.898c42.8-156.61 146.5-254.237 292.9-254.237 144.4 0 256.3 109.831 256.3 264.407 0 101.695-42.7 142.373-97.6 142.373-42.7 0-79.4-32.543-79.4-79.322 0-30.509 6.1-56.949 6.1-83.39 0-75.254-44.7-122.034-128.1-122.034-107.8 0-181 85.424-211.5 189.153-20.4 67.118-28.5 140.338-28.5 248.138v280.67c0 50.85 8.1 77.29 26.4 95.6 18.4 18.3 42.8 26.44 105.8 26.44h20.4v75.25h-427.2ZM12789.7 1128.81h71.2c-18.4 217.63-154.6 416.95-396.7 416.95-272.5 0-447.4-209.49-447.4-518.64 0-315.256 174.9-538.985 433.2-538.985 278.6 0 410.9 223.729 410.9 477.966h-701.7c0 274.579 136.2 427.119 327.4 427.119 162.7 0 260.4-97.63 303.1-264.41Zm-624.4-250.166h520.6c0-189.153-85.4-303.051-237.9-303.051-140.4 0-254.3 101.695-282.7 303.051ZM10945.8 1535.59v-498.3h81.3c20.4 284.74 223.8 416.95 427.1 416.95 164.8 0 280.7-101.7 280.7-264.41 0-406.78-789.1-176.95-789.1-722.034 0-233.898 191.2-386.44 416.9-386.44 193.2 0 258.3 83.389 321.4 83.389 22.3 0 54.9-16.271 54.9-73.22h81.3v477.966h-81.3c0-240-156.6-396.61-355.9-396.61-175 0-290.9 101.695-290.9 244.068 0 406.779 789.2 176.949 789.2 722.031 0 254.24-191.2 406.78-417 406.78-217.6 0-292.9-93.56-376.3-93.56-38.6 0-63 26.44-63 83.39h-79.3ZM9907.93 1525.42v-75.25h10.17c52.88 0 77.29-8.14 95.6-26.44 18.3-18.31 26.4-44.75 26.4-95.6V296.949c0-48.814-8.1-75.255-26.4-93.56-18.31-18.305-42.72-26.44-95.6-26.44h-10.17v-75.254h274.57V1328.13c0 50.85 8.1 77.29 26.4 95.6 18.4 18.3 42.8 26.44 95.6 26.44h10.2v75.25h-406.77Z"/><path fill="#fff" d="M9566.3 966.101V823.728c0-91.525-18.3-142.372-50.84-181.016-36.61-42.712-91.53-67.119-166.78-67.119-126.1 0-191.19 73.22-191.19 156.61 0 18.305 2.03 36.61 2.03 58.983 0 58.983-32.54 93.559-89.49 93.559-42.71 0-93.56-34.576-93.56-111.864 0-134.237 140.34-284.746 376.28-284.746 117.96 0 213.55 32.543 276.61 97.627 48.81 50.848 79.32 122.034 79.32 248.136V1313.9c0 46.78 8.13 65.08 22.37 79.32 14.24 14.24 34.58 20.34 56.95 20.34 22.37 0 58.98-10.17 89.49-48.82l44.75 32.55c-34.58 89.49-97.63 148.47-183.05 148.47-95.6 0-172.89-65.08-172.89-181.02-48.81 93.56-150.5 181.02-294.91 181.02-183.05 0-325.42-111.86-325.42-284.74 0-191.19 164.74-305.088 488.13-305.088 42.71 0 79.32 4.067 132.2 10.169Zm0 117.969v-36.61c-63.05-8.14-101.69-10.17-132.2-10.17-164.74 0-325.42 58.98-325.42 207.45 0 97.63 71.18 178.99 193.22 178.99 107.79 0 185.08-54.92 225.76-130.17 26.44-48.82 38.64-111.87 38.64-209.49ZM7805.69 1525.42v-75.25h10.17c52.88 0 77.29-8.14 95.6-26.44 18.3-18.31 26.44-44.75 26.44-95.6V703.728c0-48.813-8.14-75.254-26.44-93.559-18.31-18.305-42.72-26.44-95.6-26.44h-10.17v-75.255h264.41v213.559c44.75-134.237 170.85-233.898 335.59-233.898 83.39 0 170.85 26.441 229.83 89.492 54.92 56.949 85.43 140.339 85.43 270.508v479.995c0 50.85 8.13 77.29 26.44 95.6 18.3 18.3 42.71 26.44 95.59 26.44h10.17v75.25h-396.61v-75.25h10.17c42.71 0 67.12-8.14 85.42-26.44 18.31-18.31 26.44-44.75 26.44-95.6V886.779c0-122.034-18.3-176.949-50.84-213.559-34.58-40.678-91.53-63.051-152.55-63.051-97.62 0-172.88 38.644-219.66 97.627-46.78 56.949-75.25 134.237-75.25 274.576v345.758c0 50.85 8.14 77.29 26.44 95.6 18.31 18.3 42.71 26.44 85.42 26.44h10.17v75.25h-396.61ZM7237.32 1545.76c-278.65 0-467.8-233.9-467.8-528.81 0-292.883 189.15-528.815 467.8-528.815 278.64 0 467.79 233.899 467.79 528.815 0 292.88-189.15 528.81-467.79 528.81Zm16.27-87.46c203.39 0 282.71-178.98 282.71-388.47 0-189.153-71.19-494.237-315.26-494.237-203.38 0-282.71 178.983-282.71 388.474 0 189.153 71.19 494.233 315.26 494.233ZM6370.61 183.051c0-58.983 46.78-107.797 105.76-107.797 58.98 0 107.8 48.814 107.8 107.797s-48.82 105.762-107.8 105.762-105.76-46.779-105.76-105.762Zm-91.53 1342.369v-75.25h10.17c52.88 0 77.29-8.14 95.59-26.44 18.31-18.31 26.44-44.75 26.44-95.6V705.762c0-50.847-8.13-77.288-26.44-95.593-18.3-18.305-42.71-26.441-95.59-26.441h-10.17v-75.254h274.58v819.656c0 50.85 8.13 77.29 26.44 95.6 18.3 18.3 42.71 26.44 95.59 26.44h10.17v75.25h-406.78ZM5447.97 1535.59v-376.27h71.18c24.41 187.12 152.54 298.98 321.36 298.98 136.27 0 207.45-75.25 207.45-176.95 0-264.4-599.99-91.52-599.99-498.3 0-142.372 111.86-294.915 335.59-294.915 132.2 0 191.18 61.017 237.96 61.017 20.34 0 40.68-6.101 40.68-50.847h67.12v335.593h-71.19c-12.2-142.373-111.86-258.305-264.4-258.305-142.37 0-213.56 75.254-213.56 166.779 0 264.408 600 91.526 600 498.308 0 152.54-101.7 305.08-325.43 305.08-152.54 0-223.72-71.18-286.77-71.18-26.45 0-50.85 12.2-52.89 61.01h-67.11ZM4586.33 1535.59v-376.27h71.19c24.41 187.12 152.54 298.98 321.36 298.98 136.27 0 207.45-75.25 207.45-176.95 0-264.4-600-91.52-600-498.3 0-142.372 111.87-294.915 335.6-294.915 132.2 0 191.18 61.017 237.96 61.017 20.34 0 40.68-6.101 40.68-50.847h67.12v335.593h-71.19c-12.2-142.373-111.86-258.305-264.4-258.305-142.38 0-213.56 75.254-213.56 166.779 0 264.408 600 91.526 600 498.308 0 152.54-101.7 305.08-325.43 305.08-152.54 0-223.72-71.18-286.78-71.18-26.44 0-50.84 12.2-52.88 61.01h-67.12ZM4381.96 1128.81h71.19c-18.31 217.63-154.58 416.95-396.61 416.95-272.54 0-447.46-209.49-447.46-518.64 0-315.256 174.92-538.985 433.22-538.985 278.65 0 410.85 223.729 410.85 477.966h-701.7c0 274.579 136.28 427.119 327.46 427.119 162.71 0 260.34-97.63 303.05-264.41Zm-624.4-250.167h520.67c0-189.152-85.42-303.05-237.96-303.05-140.34 0-254.24 101.694-282.71 303.05ZM3013.95 1525.42v-75.25h10.17c52.88 0 77.28-8.14 95.59-26.44 18.3-18.31 26.44-44.75 26.44-95.6V722.033c0-63.051-10.17-79.322-22.37-91.525-14.24-14.237-30.51-24.407-93.56-24.407h-77.29v-97.627h193.22v-93.559c0-99.661 10.17-191.186 44.75-252.203C3243.78 63.051 3349.54 0 3465.47 0c156.61 0 270.51 85.424 270.51 183.051 0 48.813-32.54 81.356-77.29 81.356-36.61 0-61.02-18.305-81.35-46.78-38.65-54.915-56.95-126.102-146.45-126.102-58.98 0-93.55 24.407-115.93 61.017-30.51 48.814-36.61 115.932-36.61 166.78 0 34.576 0 105.762 10.17 189.152h274.58v97.627h-158.65c-63.05 0-79.32 10.17-93.55 24.407-12.21 12.203-22.38 28.474-22.38 91.525v606.097c0 50.85 8.14 77.29 26.44 95.6 18.31 18.3 42.71 26.44 105.77 26.44h20.33v75.25h-427.11ZM2419.13 1545.76c-278.64 0-467.8-233.9-467.8-528.81 0-292.883 189.16-528.815 467.8-528.815s467.8 233.898 467.8 528.815c0 292.88-189.16 528.81-467.8 528.81Zm16.27-87.46c203.39 0 282.71-178.98 282.71-388.47 0-189.153-71.18-494.237-315.25-494.237-203.39 0-282.71 178.982-282.71 388.474 0 189.153 71.18 494.233 315.25 494.233ZM1083.51 1525.42v-75.25h10.17c52.88 0 77.29-8.14 95.59-26.44 18.31-18.31 26.44-44.75 26.44-95.6V703.728c0-48.813-8.13-75.254-26.44-93.559-18.3-18.305-42.71-26.441-95.59-26.441h-10.17v-75.254h264.4v233.898c42.72-156.61 146.44-254.237 292.89-254.237 144.4 0 256.27 109.83 256.27 264.407 0 101.694-42.72 142.372-97.63 142.372-42.71 0-79.32-32.542-79.32-79.322 0-30.508 6.1-56.949 6.1-83.389 0-75.255-44.75-122.034-128.14-122.034-107.79 0-181.01 85.423-211.52 189.152-20.34 67.119-28.48 140.339-28.48 248.139v280.67c0 50.85 8.14 77.29 26.44 95.6 18.31 18.3 42.72 26.44 105.77 26.44h20.34v75.25h-427.12ZM0 1525.42V1440h20.34c52.88 0 77.287-8.14 95.592-26.44 18.305-18.31 26.441-44.75 26.441-95.6V309.152c0-50.847-8.136-77.288-26.441-95.593-18.305-18.305-42.712-26.441-95.593-26.441H0v-85.423h528.813c174.915 0 282.712 40.678 353.898 103.728 79.322 69.153 134.239 178.983 134.239 313.22 0 264.407-185.086 457.627-498.306 457.627-101.695 0-178.983-16.271-223.729-30.508v372.198c0 50.85 8.136 77.29 26.441 95.6 18.305 18.3 42.711 26.44 105.762 26.44h30.509v85.42H0ZM294.915 189.152v663.05c38.644 14.238 107.797 32.543 201.356 32.543 223.728 0 337.627-142.373 337.627-345.763 0-111.864-30.509-197.288-91.526-258.305-61.017-61.016-150.508-91.525-298.982-91.525H294.915Z"/></svg>`;
                
                // Convert SVG to image
                const img = new Image();
                const svgBlob = new Blob([svgString], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(svgBlob);
                
                img.onload = () => {
                    this.loadImageData(img);
                    URL.revokeObjectURL(url);
                };
                img.src = url;
            }
            
            loadImageData(image) {
                const pixelData = getPixelDataFromImage(image, { width: window.innerWidth, height: window.innerHeight }, 0.7);
                if (pixelData && pixelData.particles) {
                    this.particles = pixelData.particles;
                    this.imageBounds = pixelData.imageBounds; // Store image bounds
                    this.createParticleSystem();
                    this.hasLoaded = true;
                    
                    document.getElementById('particleCount').textContent = this.particles.length;
                }
            }
            
            createParticleSystem() {
                if (this.particleSystem) {
                    this.scene.remove(this.particleSystem);
                    this.particleSystem.geometry.dispose();
                    this.particleSystem.material.dispose();
                }
                
                const particleCount = this.particles.length;
                
                // Create geometry
                const geometry = new THREE.BufferGeometry();
                
                // Create attribute arrays
                const positions = new Float32Array(particleCount * 3);
                const originalPositions = new Float32Array(particleCount * 3);
                const sizes = new Float32Array(particleCount);
                const sensitivities = new Float32Array(particleCount);
                const masses = new Float32Array(particleCount);
                const phases = new Float32Array(particleCount);
                
                // Fill arrays with particle data
                for (let i = 0; i < particleCount; i++) {
                    const particle = this.particles[i];
                    const i3 = i * 3;
                    
                    positions[i3] = particle.currentX;
                    positions[i3 + 1] = particle.currentY;
                    positions[i3 + 2] = 0;
                    
                    originalPositions[i3] = particle.originalX;
                    originalPositions[i3 + 1] = particle.originalY;
                    originalPositions[i3 + 2] = 0;
                    
                    sizes[i] = particle.size * 5.0; // Much larger size multiplier
                    sensitivities[i] = particle.sensitivity;
                    masses[i] = particle.mass;
                    phases[i] = particle.phase;
                }
                
                // Set attributes
                geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
                geometry.setAttribute('originalPosition', new THREE.BufferAttribute(originalPositions, 3));
                geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
                geometry.setAttribute('sensitivity', new THREE.BufferAttribute(sensitivities, 1));
                geometry.setAttribute('mass', new THREE.BufferAttribute(masses, 1));
                geometry.setAttribute('phase', new THREE.BufferAttribute(phases, 1));
                
                // Create material
                const material = new THREE.ShaderMaterial({
                    vertexShader,
                    fragmentShader,
                    uniforms: {
                        uTime: { value: 0 },
                        uMouse: { value: [0, 0] },
                        uResolution: { value: [window.innerWidth, window.innerHeight] },
                        uYOffset: { value: 0 },
                        uOverrideColor: { value: new THREE.Color(this.foregroundColor) },
                        uParticleSize: { value: controlsConfig.particleSize },
                        uMagnetStrength: { value: controlsConfig.magnetStrength },
                        uReturnSpeed: { value: controlsConfig.returnSpeed },
                        uSpreadDistance: { value: controlsConfig.spreadDistance },
                        uEffectRadius: { value: controlsConfig.effectRadius }
                    },
                    transparent: true,
                    depthWrite: false
                });
                
                // Create particle system
                this.particleSystem = new THREE.Points(geometry, material);
                this.scene.add(this.particleSystem);
            }
            
            setupEventListeners() {
                // Mouse movement
                this.container.addEventListener('mousemove', (e) => {
                    const rect = this.container.getBoundingClientRect();
                    // Convert to the same coordinate system as particles
                    this.mouse.x = (e.clientX - rect.left);
                    this.mouse.y = (e.clientY - rect.top);
                });
                
                // Window resize
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    this.renderer.setSize(window.innerWidth, window.innerHeight);
                    this.updateResponsiveSettings();
                    
                    // Recreate particles with new viewport
                    if (this.hasLoaded && this.particles.length > 0) {
                        // Get the last loaded image and recreate particles
                        const lastCanvas = document.querySelector('canvas:last-of-type');
                        if (lastCanvas) {
                            const ctx = lastCanvas.getContext('2d');
                            const imageData = ctx.getImageData(0, 0, lastCanvas.width, lastCanvas.height);
                            const tempCanvas = document.createElement('canvas');
                            const tempCtx = tempCanvas.getContext('2d');
                            tempCanvas.width = lastCanvas.width;
                            tempCanvas.height = lastCanvas.height;
                            tempCtx.putImageData(imageData, 0, 0);
                            
                            const image = new Image();
                            image.onload = () => {
                                this.loadImageData(image);
                            };
                            image.src = tempCanvas.toDataURL();
                        }
                    }
                });
                
                // Image upload
                document.getElementById('imageInput').addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        const reader = new FileReader();
                        reader.onload = (event) => {
                            const image = new Image();
                            image.onload = () => {
                                this.loadImageData(image);
                            };
                            image.src = event.target.result;
                        };
                        reader.readAsDataURL(file);
                    }
                });
            }
            
            updateResponsiveSettings() {
                const width = window.innerWidth;
                const dpr = window.devicePixelRatio;
                
                let breakpoint = 'lg';
                
                if (width > 900) {
                    breakpoint = dpr > 1 ? 'lg' : 'md';
                } else {
                    breakpoint = 'sm';
                }
                
                switch(breakpoint) {
                    case 'sm':
                        controlsConfig.particleSize = 1.2; // Reduced from 2
                        controlsConfig.magnetStrength = 0.05;
                        controlsConfig.returnSpeed = 0.2;
                        controlsConfig.spreadDistance = 350;
                        controlsConfig.effectRadius = 35;
                        break;
                    case 'md':
                        controlsConfig.particleSize = 0.6; // Reduced from 1
                        controlsConfig.magnetStrength = 0.5;
                        controlsConfig.returnSpeed = 0.05;
                        controlsConfig.spreadDistance = 800;
                        controlsConfig.effectRadius = 160;
                        break;
                    case 'lg':
                        controlsConfig.particleSize = 1.0; // Reduced from 2
                        controlsConfig.magnetStrength = 0.5;
                        controlsConfig.returnSpeed = 0.05;
                        controlsConfig.spreadDistance = 1000;
                        controlsConfig.effectRadius = 160;
                        break;
                }
            }
            
            animateParticles(time, uniforms, totalParticles) {
                const mouseX = this.mouseLerp.x;
                const mouseY = this.mouseLerp.y;
                
                const currentFrame = Math.floor(time / 60);
                
                // Environment forces
                const windVariation = Math.sin(time * 0.0002) * 0.3;
                const windX = Math.cos(controlsConfig.windDirection + windVariation) * controlsConfig.windStrength;
                const windY = Math.sin(controlsConfig.windDirection + windVariation) * controlsConfig.windStrength;
                
                // Mouse velocity
                const mouseVelX = (mouseX - (this.lastMouse.x || mouseX)) * 0.1;
                const mouseVelY = (mouseY - (this.lastMouse.y || mouseY)) * 0.1;
                this.lastMouse.x = mouseX;
                this.lastMouse.y = mouseY;
                
                const geometry = this.particleSystem.geometry;
                const positions = geometry.attributes.position.array;
                
                for (let i = 0; i < totalParticles; i++) {
                    const particle = this.particles[i];
                    const phase = geometry.attributes.phase.array[i];
                    
                    const timeFactor = 1.0 + phase * controlsConfig.syncOffset * 0.1;
                    const personalTime = time * timeFactor;
                    
                    // Mouse interaction - particle positions are in screen coordinates
                    const dx = mouseX - particle.currentX;
                    const dy = mouseY - particle.currentY;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance > 0 && distance < controlsConfig.effectRadius) {
                        const angle = Math.atan2(dy, dx);
                        const timeOffset = time * 0.002;
                        
                        const organicNoise1 = Math.sin(angle * 3 + timeOffset) * controlsConfig.noiseOneMultiplier;
                        const organicNoise2 = Math.cos(angle * 5 + timeOffset * 0.7) * controlsConfig.noiseTwoMultiplier;
                        const organicNoise3 = Math.sin(angle * 7 + timeOffset * 1.3 + particle.phase) * controlsConfig.noiseThreeMultiplier;
                        
                        const baseRadius = controlsConfig.effectRadius;
                        const organicRadius = baseRadius * (0.9 + organicNoise1 + organicNoise2 + organicNoise3);
                        
                        const innerRadius = organicRadius * 0.4;
                        const midRadius = organicRadius * 0.7;
                        
                        const proximityFactor = 1.0 - (distance / organicRadius);
                        const spreadScale = 1.0 + (controlsConfig.spreadDistance / 2000.0);
                        
                        let totalForce = 0;
                        let forceAngle = angle;
                        
                        if (distance < innerRadius) {
                            const innerProximity = 1.0 - (distance / innerRadius);
                            const attractionForce = innerProximity * innerProximity * controlsConfig.mouseForce * 0.8 * spreadScale;
                            
                            // Strong attraction to mouse with slight organic variation
                            const attractionAngle = angle + (Math.random() - 0.5) * Math.PI * 0.2;
                            const magneticPull = Math.exp(-distance / (innerRadius * 0.1));
                            
                            totalForce += attractionForce;
                            forceAngle = attractionAngle;
                            
                            // Add magnetic clustering effect
                            const clusterScale = spreadScale * magneticPull * 20.0;
                            particle.vx += Math.cos(angle) * clusterScale;
                            particle.vy += Math.sin(angle) * clusterScale;
                            
                        } else if (distance < midRadius) {
                            const midProximity = 1.0 - (distance / midRadius);
                            const magneticForce = midProximity * controlsConfig.mouseForce * 0.4 * spreadScale;
                            
                            // Gentle spiral attraction
                            const spiralAngle = angle - Math.PI * 0.1; // Slight spiral inward
                            const spiralStrength = midProximity * 40;
                            const spiralX = Math.cos(spiralAngle) * spiralStrength;
                            const spiralY = Math.sin(spiralAngle) * spiralStrength;
                            
                            totalForce += magneticForce;
                            particle.vx += spiralX;
                            particle.vy += spiralY;
                        } else {
                            const outerProximity = 1.0 - (distance / organicRadius);
                            const gentleAttraction = outerProximity * controlsConfig.mouseForce * 0.2 * spreadScale;
                            totalForce += gentleAttraction;
                        }
                        
                        const organicAngleVariation = (organicNoise1 + organicNoise2) * 0.2; // Reduced variation for smoother clustering
                        const finalAngle = forceAngle + organicAngleVariation;
                        
                        // REVERSED: Attract particles TO the mouse instead of away
                        particle.vx += Math.cos(finalAngle) * totalForce;
                        particle.vy += Math.sin(finalAngle) * totalForce;
                        
                        // Mouse velocity creates a trailing effect
                        const velocityInfluence = proximityFactor * 15;
                        particle.vx += mouseVelX * velocityInfluence;
                        particle.vy += mouseVelY * velocityInfluence;
                    }
                    
                    // Environment forces - ultra-minimal for smooth movement
                    const atmosphericSensitivity = particle.sensitivity * controlsConfig.flowCoherence;
                    
                    // Check if mouse is hovering (within effect radius)
                    const mouseDistX = mouseX - particle.currentX;
                    const mouseDistY = mouseY - particle.currentY;
                    const mouseDist = Math.sqrt(mouseDistX * mouseDistX + mouseDistY * mouseDistY);
                    const isNearMouse = mouseDist < controlsConfig.effectRadius;
                    
                    // Reduce forces when mouse is hovering
                    const forceMultiplier = isNearMouse ? 0.1 : 1.0; // 90% reduction when hovering
                    
                    particle.vx += windX * atmosphericSensitivity * 0.2 * forceMultiplier; // Ultra-minimal wind effect
                    particle.vy += windY * atmosphericSensitivity * 0.2 * forceMultiplier;
                    
                    // Buoyancy - ultra-minimal
                    particle.vy -= controlsConfig.buoyancy * particle.sensitivity * 0.02 * forceMultiplier; // Ultra-minimal effect
                    
                    // Brownian motion - ultra-smooth, reduced when hovering
                    const brownianScale = controlsConfig.brownianStrength * particle.sensitivity * 0.05 * forceMultiplier; // Ultra-minimal
                    const turbulenceScale = controlsConfig.turbulence * 0.02 * forceMultiplier; // Ultra-minimal
                    particle.vx += (Math.random() - 0.5) * (brownianScale + turbulenceScale) * 0.02; // Ultra-minimal random movement
                    particle.vy += (Math.random() - 0.5) * (brownianScale + turbulenceScale) * 0.02;
                    
                    // Independent drift - ultra-smooth, reduced when hovering
                    const driftStrength = controlsConfig.driftIndependence * 0.02 * forceMultiplier; // Ultra-minimal drift
                    const organicFlow = Math.sin(personalTime * 0.000005 + particle.personalDrift) * driftStrength; // Ultra-slow oscillation
                    particle.vx += Math.cos(personalTime * 0.000005 + particle.personalDrift) * organicFlow * 0.02; // Ultra-minimal effect
                    particle.vy += Math.sin(personalTime * 0.0000075 + particle.personalDrift) * organicFlow * 0.02;
                    
                    // Return force - balanced for image-contained movement  
                    if (controlsConfig.returnSpeed > 0) {
                        const returnDx = particle.originalX - particle.currentX;
                        const returnDy = particle.originalY - particle.currentY;
                        const returnDistance = Math.sqrt(returnDx * returnDx + returnDy * returnDy);
                        
                        if (returnDistance > 2.0) {
                            const maxReturnDistance = controlsConfig.spreadDistance * 0.15;
                            const distanceRatio = returnDistance / maxReturnDistance;
                            
                            const baseReturnForce = controlsConfig.returnSpeed * 200 * controlsConfig.magnetStrength;
                            const distanceMultiplier = 1.0 + distanceRatio * 3.0;
                            const balancedReturn = baseReturnForce * distanceMultiplier;
                            
                            const returnForceX = (returnDx / returnDistance) * balancedReturn;
                            const returnForceY = (returnDy / returnDistance) * balancedReturn;
                            
                            particle.vx += returnForceX;
                            particle.vy += returnForceY;
                            
                            // Emergency return for particles too far from origin
                            if (distanceRatio > 3.0) {
                                const urgentForce = controlsConfig.returnSpeed * 1000 * controlsConfig.magnetStrength;
                                particle.vx += (returnDx / returnDistance) * urgentForce;
                                particle.vy += (returnDy / returnDistance) * urgentForce;
                            }
                        }
                    }
                    
                    // Damping - ultra-strong for smooth movement, enhanced when hovering
                    const personalDamping = controlsConfig.inertialDamping * particle.mass;
                    const baseResistance = controlsConfig.forceFade * (1.0 - personalDamping * 0.25); // Ultra-strong damping effect
                    const hoverResistance = isNearMouse ? 0.99 : baseResistance; // Extra damping when hovering
                    
                    particle.vx *= hoverResistance;
                    particle.vy *= hoverResistance;
                    
                    // Velocity limits - ultra-low for smooth movement
                    const maxVelocity = (20 + controlsConfig.spreadDistance * 0.002) / particle.mass; // Ultra-low velocity limit
                    const currentSpeed = Math.sqrt(particle.vx * particle.vx + particle.vy * particle.vy);
                    if (currentSpeed > maxVelocity) {
                        const scale = maxVelocity / currentSpeed;
                        particle.vx *= scale;
                        particle.vy *= scale;
                    }
                    
                    // Update position
                    const newX = particle.currentX + particle.vx;
                    const newY = particle.currentY + particle.vy;
                    
                    // Check if new position is inside SVG boundaries
                    if (isInsideSVGBounds(newX, newY, this.imageBounds)) {
                        particle.currentX = newX;
                        particle.currentY = newY;
                    } else {
                        // Find nearest valid position and apply soft bounce
                        const validPos = findNearestValidPosition(newX, newY, this.imageBounds, 15);
                        
                        // Apply bounce effect by reversing velocity components
                        const bounceForce = 0.3;
                        if (!isInsideSVGBounds(newX, particle.currentY, this.imageBounds)) {
                            particle.vx *= -bounceForce; // Bounce horizontally
                        }
                        if (!isInsideSVGBounds(particle.currentX, newY, this.imageBounds)) {
                            particle.vy *= -bounceForce; // Bounce vertically
                        }
                        
                        // Move to valid position
                        particle.currentX = validPos.x;
                        particle.currentY = validPos.y;
                        
                        // Add ultra-minimal randomness to prevent particles getting stuck, reduced when hovering
                        const randomMultiplier = isNearMouse ? 0.02 : 0.1; // Much less randomness when hovering
                        particle.vx += (Math.random() - 0.5) * randomMultiplier;
                        particle.vy += (Math.random() - 0.5) * randomMultiplier;
                    }
                    
                    // Update position buffer - positions are stored in screen coordinates
                    const i3 = i * 3;
                    positions[i3] = particle.currentX;
                    positions[i3 + 1] = particle.currentY;
                    positions[i3 + 2] = 0;
                }
                
                geometry.attributes.position.needsUpdate = true;
            }
            
            animate() {
                requestAnimationFrame(() => this.animate());
                
                if (!this.hasLoaded || !this.particleSystem) return;
                
                const time = this.clock.getElapsedTime() * 100;
                const currentTime = this.clock.getElapsedTime();
                const timeDelta = currentTime - this.lastTime;
                
                // FPS calculation
                if (timeDelta > 1) {
                    this.fps = Math.round(this.frameCount / timeDelta);
                    document.getElementById('fps').textContent = this.fps;
                    this.frameCount = 0;
                    this.lastTime = currentTime;
                }
                this.frameCount++;
                
                // Smooth mouse interpolation
                this.mouseLerp.x = lerp(this.mouseLerp.x, this.mouse.x, 0.1);
                this.mouseLerp.y = lerp(this.mouseLerp.y, this.mouse.y, 0.1);
                
                // Update uniforms
                const uniforms = this.particleSystem.material.uniforms;
                uniforms.uTime.value = time;
                uniforms.uMouse.value = [this.mouseLerp.x, this.mouseLerp.y];
                uniforms.uResolution.value = [window.innerWidth, window.innerHeight];
                
                // Update control uniforms
                uniforms.uParticleSize.value = controlsConfig.particleSize;
                uniforms.uMagnetStrength.value = controlsConfig.magnetStrength;
                uniforms.uReturnSpeed.value = controlsConfig.returnSpeed;
                uniforms.uSpreadDistance.value = controlsConfig.spreadDistance;
                uniforms.uEffectRadius.value = controlsConfig.effectRadius;
                
                // Animate particles
                if (this.particles.length > 0 && this.inView) {
                    this.animateParticles(time, uniforms, this.particles.length);
                }
                
                // Color transitions
                if (this.backgroundMesh) {
                    const targetBg = new THREE.Color(this.backgroundColor);
                    const targetFg = new THREE.Color(this.foregroundColor);
                    
                    this.backgroundMesh.material.color.lerp(targetBg, 0.025);
                    uniforms.uOverrideColor.value.lerp(targetFg, 0.025);
                }
                
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // Initialize the application
        new InteractiveLogo();
    </script>
</body>
</html>