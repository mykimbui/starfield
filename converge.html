<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Starfield with Mouse Magnet Effect</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: black;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: white;
            font-size: 14px;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
        }
        
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-size: 12px;
            z-index: 100;
            background: rgba(0,0,0,0.7);
            padding: 10px;
            border-radius: 5px;
        }
        
        button {
            background: #333;
            color: white;
            border: 1px solid #555;
            padding: 5px 10px;
            border-radius: 3px;
            cursor: pointer;
            margin: 2px;
        }
        
        button:hover {
            background: #555;
        }
    </style>
</head>
<body>
    <div id="info">
        <strong>3D Starfield</strong><br>
        Move mouse to cluster nearby stars<br>
        Rounded glowing dots with soft halos<br>
        Stars: <span id="starCount">0</span>
    </div>
    
    <div id="controls">
        <button id="toggleOrbit">Enable Orbit Controls</button><br>
        <button id="resetStars">Reset Star Positions</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, stars, starGeometry;
        let mouse = new THREE.Vector2();
        let raycaster = new THREE.Raycaster();
        let orbitControlsEnabled = false;
        let orbitControls = null;
        let starTexture;
        
        // Star configuration
        const STAR_COUNT = 2000;
        const STAR_SIZE = 8;
        const MAGNET_RADIUS = 250;
        const MAGNET_STRENGTH = 0.08;
        const RESTORE_SPEED = 0.01;
        const CLUSTER_STRENGTH = 3.0;
        
        // Store original and current positions
        let originalPositions = [];
        let currentPositions = [];
        let targetPositions = [];
        
        // Glow effect system
        let starGlowStates = [];
        let starGlowTimers = [];
        let starSizes = [];
        let starColors = [];
        let starTypes = []; // 0 = normal, 1 = special glowing star
        
        function init() {
            // Create scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000);
            
            // Create camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.z = 100;
            
            // Create renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            
            // Create star texture
            createStarTexture();
            
            createStarfield();
            setupEventListeners();
            
            // Update star count display
            document.getElementById('starCount').textContent = STAR_COUNT;
            
            animate();
        }
        
        function createStarTexture() {
            // Create a canvas for the star texture
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const context = canvas.getContext('2d');
            
            // Create radial gradient for glow effect
            const gradient = context.createRadialGradient(32, 32, 0, 32, 32, 32);
            gradient.addColorStop(0, 'rgba(255, 255, 255, 1.0)');     // Bright white center
            gradient.addColorStop(0.3, 'rgba(255, 255, 255, 0.8)');   // Bright glow
            gradient.addColorStop(0.6, 'rgba(255, 255, 255, 0.4)');   // Soft glow
            gradient.addColorStop(0.8, 'rgba(255, 255, 255, 0.1)');   // Very soft outer glow
            gradient.addColorStop(1, 'rgba(255, 255, 255, 0.0)');     // Transparent edges
            
            // Fill the canvas with the gradient
            context.fillStyle = gradient;
            context.fillRect(0, 0, 64, 64);
            
            // Create texture from canvas
            starTexture = new THREE.CanvasTexture(canvas);
            starTexture.needsUpdate = true;
        }
        
        function createStarfield() {
            // Create geometry for stars
            starGeometry = new THREE.BufferGeometry();
            
            // Generate random positions for stars
            const positions = new Float32Array(STAR_COUNT * 3);
            const sizes = new Float32Array(STAR_COUNT);
            const colors = new Float32Array(STAR_COUNT * 3);
            
            originalPositions = [];
            currentPositions = [];
            targetPositions = [];
            starGlowStates = [];
            starGlowTimers = [];
            starSizes = [];
            starColors = [];
            starTypes = [];
            
            for (let i = 0; i < STAR_COUNT; i++) {
                const x = (Math.random() - 0.5) * 400;
                const y = (Math.random() - 0.5) * 400;
                const z = (Math.random() - 0.5) * 400;
                
                positions[i * 3] = x;
                positions[i * 3 + 1] = y;
                positions[i * 3 + 2] = z;
                
                // Store original positions
                originalPositions.push(new THREE.Vector3(x, y, z));
                currentPositions.push(new THREE.Vector3(x, y, z));
                targetPositions.push(new THREE.Vector3(x, y, z));
                
                // Determine star type (20% chance of being a special glowing star)
                const isGlowingStar = Math.random() < 0.2;
                starTypes.push(isGlowingStar ? 1 : 0);
                
                // Initialize glow system
                starGlowStates.push(0); // 0 = normal, 1 = glowing
                if (isGlowingStar) {
                    starGlowTimers.push(Math.random() * 180 + 60); // Shorter delay for glowing stars
                } else {
                    starGlowTimers.push(Math.random() * 600 + 300); // Longer delay for normal stars
                }
                
                starSizes.push(isGlowingStar ? STAR_SIZE * 0.6 : STAR_SIZE * 0.8);
                starColors.push(new THREE.Color(1, 1, 1));
                
                // Set initial size and color
                sizes[i] = isGlowingStar ? STAR_SIZE * 0.6 : STAR_SIZE * 0.8;
                if (isGlowingStar) {
                    colors[i * 3] = 0.4;     // R - much dimmer when not glowing
                    colors[i * 3 + 1] = 0.5; // G
                    colors[i * 3 + 2] = 0.8; // B - blue tint
                } else {
                    colors[i * 3] = 0.6;     // R
                    colors[i * 3 + 1] = 0.6; // G  
                    colors[i * 3 + 2] = 0.6; // B
                }
            }
            
            starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            starGeometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            starGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // Create material for stars with glow texture
            const starMaterial = new THREE.PointsMaterial({
                map: starTexture,
                vertexColors: true,
                sizeAttenuation: true,
                transparent: true,
                opacity: 1.0,
                blending: THREE.AdditiveBlending,  // Additive blending for glow effect
                depthWrite: false                  // Disable depth writing for proper blending
            });
            
            // Create points object
            stars = new THREE.Points(starGeometry, starMaterial);
            scene.add(stars);
        }
        
        function setupEventListeners() {
            // Mouse move event
            window.addEventListener('mousemove', onMouseMove, false);
            
            // Window resize event
            window.addEventListener('resize', onWindowResize, false);
            
            // Control buttons
            document.getElementById('toggleOrbit').addEventListener('click', toggleOrbitControls);
            document.getElementById('resetStars').addEventListener('click', resetStarPositions);
        }
        
        function onMouseMove(event) {
            // Convert mouse coordinates to normalized device coordinates
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
            
            // Update raycaster
            raycaster.setFromCamera(mouse, camera);
            
            // Get mouse position in world coordinates at a certain depth
            const mouseWorldPos = new THREE.Vector3();
            mouseWorldPos.copy(raycaster.ray.direction);
            mouseWorldPos.multiplyScalar(camera.position.z);
            mouseWorldPos.add(raycaster.ray.origin);
            
            // Apply magnet effect to nearby stars
            applyMagnetEffect(mouseWorldPos);
        }
        
        function applyMagnetEffect(mouseWorldPos) {
            const positions = starGeometry.attributes.position.array;
            
            for (let i = 0; i < STAR_COUNT; i++) {
                const starPos = currentPositions[i];
                const originalPos = originalPositions[i];
                
                // Calculate distance from mouse to star
                const distance = starPos.distanceTo(mouseWorldPos);
                
                if (distance < MAGNET_RADIUS) {
                    // Calculate magnet strength based on distance (closer = stronger)
                    const normalizedDistance = distance / MAGNET_RADIUS;
                    const strength = (1 - normalizedDistance * normalizedDistance) * MAGNET_STRENGTH;
                    
                    // Calculate direction from star to mouse
                    const direction = new THREE.Vector3();
                    direction.subVectors(mouseWorldPos, starPos);
                    direction.normalize();
                    direction.multiplyScalar(strength * CLUSTER_STRENGTH * 20);
                    
                    // Set target position towards mouse with clustering
                    targetPositions[i].copy(starPos);
                    targetPositions[i].add(direction);
                    
                    // Add some clustering randomness for more natural look
                    const randomOffset = new THREE.Vector3(
                        (Math.random() - 0.5) * 5,
                        (Math.random() - 0.5) * 5,
                        (Math.random() - 0.5) * 5
                    );
                    targetPositions[i].add(randomOffset);
                } else {
                    // Gradually return to original position
                    targetPositions[i].copy(originalPos);
                }
            }
        }
        
        function updateStarPositions() {
            const positions = starGeometry.attributes.position.array;
            
            for (let i = 0; i < STAR_COUNT; i++) {
                // Smoothly interpolate current position towards target position
                currentPositions[i].lerp(targetPositions[i], 0.15);
                
                // Update geometry positions
                positions[i * 3] = currentPositions[i].x;
                positions[i * 3 + 1] = currentPositions[i].y;
                positions[i * 3 + 2] = currentPositions[i].z;
            }
            
            // Mark positions as needing update
            starGeometry.attributes.position.needsUpdate = true;
        }
        
        function updateGlowEffects() {
            const sizes = starGeometry.attributes.size.array;
            const colors = starGeometry.attributes.color.array;
            const time = Date.now();
            
            for (let i = 0; i < STAR_COUNT; i++) {
                starGlowTimers[i] -= 16; // Approximate 60fps
                
                const isGlowingStar = starTypes[i] === 1;
                
                // Different glow probabilities for different star types
                let glowChance = isGlowingStar ? 0.008 : 0.0003; // Glowing stars glow much more frequently
                
                // Random chance to start glowing
                if (starGlowStates[i] === 0 && starGlowTimers[i] <= 0 && Math.random() < glowChance) {
                    starGlowStates[i] = 1;
                    starGlowTimers[i] = isGlowingStar ? 180 + Math.random() * 120 : 90 + Math.random() * 60; // Different glow durations
                }
                
                // Handle glow animation
                if (starGlowStates[i] === 1) {
                    const glowProgress = starGlowTimers[i] / (isGlowingStar ? 300 : 150);
                    const glowIntensity = Math.sin(time * 0.008 + i * 0.1) * 0.5 + 0.5; // Pulsing
                    const glow = glowProgress * glowIntensity;
                    
                    if (isGlowingStar) {
                        // Special glowing stars - dramatic glow effect
                        starSizes[i] = STAR_SIZE * 0.6 + glow * 25; // Much bigger glow
                        sizes[i] = starSizes[i];
                        
                        // Intense bright glow with additive blending
                        const colorIntensity = 0.3 + glow * 2.0;
                        colors[i * 3] = Math.min(2, colorIntensity * 0.8);     // R
                        colors[i * 3 + 1] = Math.min(2, colorIntensity * 0.9); // G
                        colors[i * 3 + 2] = Math.min(2, colorIntensity * 1.5); // B - strong blue tint
                    } else {
                        // Normal stars - subtle glow
                        starSizes[i] = STAR_SIZE * 0.8 + glow * 12;
                        sizes[i] = starSizes[i];
                        
                        // Gentle white glow
                        const colorIntensity = 0.4 + glow * 1.2;
                        colors[i * 3] = Math.min(1.5, colorIntensity);     // R
                        colors[i * 3 + 1] = Math.min(1.5, colorIntensity); // G
                        colors[i * 3 + 2] = Math.min(1.5, colorIntensity + glow * 0.3); // B
                    }
                    
                    // End glow
                    if (starGlowTimers[i] <= 0) {
                        starGlowStates[i] = 0;
                        if (isGlowingStar) {
                            starGlowTimers[i] = 120 + Math.random() * 300; // 2-7 seconds until next glow
                        } else {
                            starGlowTimers[i] = 600 + Math.random() * 1200; // 10-30 seconds until next glow
                        }
                    }
                } else {
                    // Normal state
                    if (isGlowingStar) {
                        starSizes[i] = STAR_SIZE * 0.6;
                        sizes[i] = STAR_SIZE * 0.6;
                        colors[i * 3] = 0.4;     // R - dim blue-white
                        colors[i * 3 + 1] = 0.5; // G
                        colors[i * 3 + 2] = 0.8; // B
                    } else {
                        starSizes[i] = STAR_SIZE * 0.8;
                        sizes[i] = STAR_SIZE * 0.8;
                        colors[i * 3] = 0.6;     // R
                        colors[i * 3 + 1] = 0.6; // G
                        colors[i * 3 + 2] = 0.6; // B
                    }
                }
            }
            
            // Mark attributes as needing update
            starGeometry.attributes.size.needsUpdate = true;
            starGeometry.attributes.color.needsUpdate = true;
        }
        
        function toggleOrbitControls() {
            const button = document.getElementById('toggleOrbit');
            
            if (!orbitControlsEnabled) {
                // Enable orbit controls (Note: OrbitControls not available in r128, using manual rotation)
                orbitControlsEnabled = true;
                button.textContent = 'Disable Orbit Controls';
                
                // Add rotation controls
                window.addEventListener('mousedown', startRotation);
                window.addEventListener('mouseup', stopRotation);
                window.addEventListener('wheel', onMouseWheel);
            } else {
                // Disable orbit controls
                orbitControlsEnabled = false;
                button.textContent = 'Enable Orbit Controls';
                
                // Remove rotation controls
                window.removeEventListener('mousedown', startRotation);
                window.removeEventListener('mouseup', stopRotation);
                window.removeEventListener('wheel', onMouseWheel);
                isRotating = false;
            }
        }
        
        let isRotating = false;
        let previousMousePosition = { x: 0, y: 0 };
        
        function startRotation(event) {
            if (!orbitControlsEnabled) return;
            isRotating = true;
            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
        }
        
        function stopRotation() {
            isRotating = false;
        }
        
        function onMouseWheel(event) {
            if (!orbitControlsEnabled) return;
            camera.position.z += event.deltaY * 0.1;
            camera.position.z = Math.max(10, Math.min(500, camera.position.z));
        }
        
        function handleRotation(event) {
            if (!isRotating || !orbitControlsEnabled) return;
            
            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;
            
            // Rotate camera around the scene
            const spherical = new THREE.Spherical();
            spherical.setFromVector3(camera.position);
            spherical.theta -= deltaX * 0.01;
            spherical.phi += deltaY * 0.01;
            spherical.phi = Math.max(0.1, Math.min(Math.PI - 0.1, spherical.phi));
            
            camera.position.setFromSpherical(spherical);
            camera.lookAt(0, 0, 0);
            
            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
        }
        
        // Add rotation handling to mousemove
        window.addEventListener('mousemove', handleRotation);
        
        function resetStarPositions() {
            // Reset all stars to their original positions
            for (let i = 0; i < STAR_COUNT; i++) {
                currentPositions[i].copy(originalPositions[i]);
                targetPositions[i].copy(originalPositions[i]);
                
                const isGlowingStar = starTypes[i] === 1;
                
                // Reset glow states
                starGlowStates[i] = 0;
                starGlowTimers[i] = isGlowingStar ? Math.random() * 180 + 60 : Math.random() * 600 + 300;
                starSizes[i] = isGlowingStar ? STAR_SIZE * 0.6 : STAR_SIZE * 0.8;
            }
            
            const positions = starGeometry.attributes.position.array;
            const sizes = starGeometry.attributes.size.array;
            const colors = starGeometry.attributes.color.array;
            
            for (let i = 0; i < STAR_COUNT; i++) {
                const isGlowingStar = starTypes[i] === 1;
                
                positions[i * 3] = originalPositions[i].x;
                positions[i * 3 + 1] = originalPositions[i].y;
                positions[i * 3 + 2] = originalPositions[i].z;
                
                sizes[i] = isGlowingStar ? STAR_SIZE * 0.6 : STAR_SIZE * 0.8;
                
                if (isGlowingStar) {
                    colors[i * 3] = 0.4;     // R
                    colors[i * 3 + 1] = 0.5; // G
                    colors[i * 3 + 2] = 0.8; // B
                } else {
                    colors[i * 3] = 0.6;     // R
                    colors[i * 3 + 1] = 0.6; // G
                    colors[i * 3 + 2] = 0.6; // B
                }
            }
            
            starGeometry.attributes.position.needsUpdate = true;
            starGeometry.attributes.size.needsUpdate = true;
            starGeometry.attributes.color.needsUpdate = true;
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            // Update star positions based on mouse interaction
            updateStarPositions();
            
            // Update glow effects
            updateGlowEffects();
            
            // Render the scene
            renderer.render(scene, camera);
        }
        
        // Initialize the application
        init();
    </script>
</body>
</html>